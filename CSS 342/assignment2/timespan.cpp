// By Ruiqi Huang
// 1/24/2023
// 
// This is where all the implementation of Timespan is going to be. All description of functions are located in the TimeSpan header file
// Which is timespan.h.
//
#define _CRT_SECURE_NO_WARNINGS
#include "timespan.h"

//Autogenerated constructor
TimeSpan::TimeSpan()
{
    hour = 0;
    minute = 0;
    second = 0;

}

//Assuming hour and minute is 0. Seconds is double because we allow users to input double as argument.
TimeSpan::TimeSpan(double seconds)
{
    //We can simplify everything by just using SetTime to set the correct time
    SetTime(0, 0, seconds);
}

//Assuming hour is 0. Like above everything is assumed to be doubled because users are allowed to input doubles.
TimeSpan::TimeSpan(double minutes, double seconds)
{
    SetTime(0, minutes, seconds);
}

TimeSpan::TimeSpan(double hours, double minutes, double seconds)
{
    SetTime(hours, minutes, seconds);
}

//Getters for hour
int TimeSpan::hours() const
{
    return hour;
}

//Getters for minute
int TimeSpan::minutes() const
{
    return minute;
}

//Getters for second
int TimeSpan::seconds() const
{
    return second;
}

//PRE-CONDITION: We cannot have decimal number of seconds. 
//We can use this method to set the time according to our constraints
void TimeSpan::SetTime(double hours, double minutes, double seconds)
{
    
    //This will convert everything to seconds. This helps us set the time easier as we are only focusing on seconds.
    //There is 3600 seconds in an hour and 60 seconds in a minute so everything is converted accordingly.
    double total_seconds = (hours * 3600) + (minutes * 60) + seconds;

    //We cannot have decimal number of seconds.
    total_seconds = round(total_seconds);

    
    //Now we can convert everything correctly
    hour = ((int)total_seconds / 3600);
    //Minutes is what is left over after converting to hours. Must be int to use %
    minute = ((int)total_seconds % 3600) / 60;
    //Seconds is what is left over after converting to hours and minutes. Must be int to use %
    second = ((int)total_seconds % 3600) % 60;
}

//Check if this TimeSpan is equal to our other(time) TimeSpan
bool TimeSpan::operator==(const TimeSpan& time) const
{
    //this is saying that is all these are true then return true.
    return ((hour == time.hour) && (minute == time.minute) && (second == time.second));
}

//Check if this TimeSpan is not equal to our other(time) TimeSpan
bool TimeSpan::operator!=(const TimeSpan& time) const
{
    //Checking hour or minute or second does not equal.
    if ((hour != time.hour) || (minute != time.minute) || (second != time.second)) {
        return true;
    }
    else {
        return false;
    }
}

//Check if this TimeSpan is smaller than the other(time) TimeSpan
bool TimeSpan::operator<(const TimeSpan& time) const
{
    //This will hold the total second of the rhs TimeSpan (rhs = right hand side)
    double this_total_seconds = (this->hour * 3600) + (this->minute * 60) + this->second;
    //This will hold the total second of the lhs TimeSpan (lhs = left hand side)
    double total_seconds = (time.hour * 3600) + (time.minute * 60) + time.second;
    if (this_total_seconds < total_seconds) {
        return true;
    }
    return false;
}

//Check if this TimeSpan is smaller or equal to the other(time) TimeSpan
bool TimeSpan::operator<=(const TimeSpan& time) const
{
    //This will hold the total second of the rhs TimeSpan (rhs = right hand side)
    double this_total_seconds = (this->hour * 3600) + (this->minute * 60) + this->second;
    //This will hold the total second of the lhs TimeSpan (lhs = left hand side)
    double total_seconds = (time.hour * 3600) + (time.minute * 60) + time.second;
    if (this_total_seconds < total_seconds) {
        return true;
    }
    else if ((hour == time.hour) && (minute == time.minute) && (second == time.second)) {
        return true;
    }
    return false;
}

//Check if this TimeSpain is bigger than the other(time) TimeSpan
bool TimeSpan::operator>(const TimeSpan& time) const
{
    //This will hold the total second of the rhs TimeSpan (rhs = right hand side)
    double this_total_seconds = (this->hour * 3600) + (this->minute * 60) + this->second;
    //This will hold the total second of the lhs TimeSpan (lhs = left hand side)
    double total_seconds = (time.hour * 3600) + (time.minute * 60) + time.second;
    if (this_total_seconds > total_seconds) {
        return true;
    }
    return false;
}

//Check if this TimeSpain is bigger or equal to the toher(time) TimeSpan
bool TimeSpan::operator>=(const TimeSpan& time) const
{
    //This will hold the total second of the rhs TimeSpan (rhs = right hand side)
    double this_total_seconds = (this->hour * 3600) + (this->minute * 60) + this->second;
    //This will hold the total second of the lhs TimeSpan (lhs = left hand side)
    double total_seconds = (time.hour * 3600) + (time.minute * 60) + time.second;
    if (this_total_seconds > total_seconds) {
        return true;
    }
    else if ((hour == time.hour) && (minute == time.minute) && (second == time.second)) {
        return true;
    }
    return false;
}

//Adds two TimeSpan together
TimeSpan TimeSpan::operator+(const TimeSpan& time) const
{
    return TimeSpan((hour + time.hour), (minute + time.minute), (second + time.second));
}

//Add the other TimeSpan to this TimeSpan
TimeSpan& TimeSpan::operator+=(const TimeSpan& time)
{
    this->hour += time.hour;
    this->minute += time.minute;
    this->second += time.second;
    
    //Using this SetTime function to make sure the time is correct
    SetTime(this->hour, this->minute, this->second);

    return *this;
}
//Subtract two TimeSpans
TimeSpan TimeSpan::operator-(const TimeSpan& time) const
{
    return TimeSpan((hour - time.hour), (minute - time.minute), (second - time.second));
}

//Subtracts the other TimeSpan to this TimeSpan
TimeSpan& TimeSpan::operator-=(const TimeSpan& time)
{
    this->hour -= time.hour;
    this->minute -= time.minute;
    this->second -= time.second;

    //Using this SetTime function to make sure the time is correct
    SetTime(this->hour, this->minute, this->second);

    return *this;
}

//Multiply this TimeSpan with an integer given 
TimeSpan TimeSpan::operator*(int number) const
{
    return TimeSpan((hour * number), (minute * number), (second * number));
}

//Prints out our time in this form: 0:00:00 where it is hour:minute:second 
ostream& operator<<(ostream& out, const TimeSpan& time)
{
    //Our buffer for our sprintf. It will hold our time in chars in array.
    char s[13];

    //Checks if the time is positive. If so we can just print it. If not we have to make it so it prints with only one negative sign in front.
    if ((time.hours() >= 0) && (time.minutes() >= 0) && ( time.seconds() >= 0)) {
        sprintf(s, "%d:%02d:%02d", time.hours(), time.minutes(), time.seconds());
        out << s;
        return out;
    }
    else {

        //Here I am making the negative values positive just for display. Making a new variable to hold that positive value so it won't change the actual value.
        int new_hour = time.hours() - (time.hours() * 2);
        int new_minute = time.minutes() - (time.minutes() * 2);
        int new_second = time.seconds() - (time.seconds() * 2);

        sprintf(s, "-%d:%02d:%02d", new_hour, new_minute, new_second);
        out << s;
        return out;
    }
}
